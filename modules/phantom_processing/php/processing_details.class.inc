<?php
/**
 * Endpoint for phantom_processing
 *
 * PHP Version 7
 *
 * @category   Endpoint
 * @package    Imaging
 * @subpackage Processing
 * @author     Xavier Lecours Boucher <xavier.lecoursboucher@mcgill.ca>
 * @license    http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link       https://www.github.com/aces/Loris-Trunk/
 */
namespace LORIS\phantom_processing;
use \Psr\Http\Message\ServerRequestInterface;
use \Psr\Http\Message\ResponseInterface;
use \Psr\Http\Server\RequestHandlerInterface;
use \LORIS\server_processes_manager\ServerProcessLauncher;
use \LORIS\server_processes_manager\ServerProcessesMonitor;

/**
 * Endpoint handler for phantom_processing
 *
 * PHP Version 7
 *
 * @category   Endpoint
 * @package    Imaging
 * @subpackage Processing
 * @author     Xavier Lecours Boucher <xavier.lecoursboucher@mcgill.ca>
 * @license    http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link       https://www.github.com/aces/Loris-Trunk/
 */
class Processing_Details extends \NDB_Page
{
    public $skipTemplate = true;

    public function _hasAccess()
    {
        return \NDB_Factory::singleton()
            ->user()
            ->hasPermission('phantom_processing');
    }

    /**
     * An NDB_Page can act as both a middleware, or a handler, depending on the
     * context. When treated as a middleware, the page is responsible for setting
     * up any middleware required to access the page. By default, this will
     * implement the page decoration middlewares which is responsible for adding
     * the LORIS menu's/headers/footers/etc.
     * This can be overridden by modules who don't want this behaviour (such
     * as API endpoints).
     *
     * @param ServerRequestInterface  $request The PSR7 request being processed.
     * @param RequestHandlerInterface $handler The handler to handle the request
     *                                         after processing the middleware.
     *
     * @return ResponseInterface the PSR15 response that was generated by the
     * middleware
     */
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ) : ResponseInterface {
        if (preg_match('/application\/json/',$request->getHeaderLine('Accept')) === 0 ) {
           return parent::handle($request);
        }

        $sessionid = $request->getQueryParams()['sessionid'] ?? null;
        return $this->handle($request->withAttribute(
            'session',
            \TimePoint::singleton($sessionid)
        ));
    }

    /**
     * Handles a request and produces a response.
     *
     * @param ServerRequestInterface  $request The PSR7 request being processed.
     *
     * @return ResponseInterface the PSR15 response
     */
    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        switch($request->getMethod()) {
            case 'POST':
                return $this->handlePOST($request);

            case 'GET':
            default:
                return $this->handleGET($request);
        }
    }

    public function handleGET(ServerRequestInterface $request): ResponseInterface
    {
        $session = $request->getAttribute('session');
        $MySQLAccessor = new PhantomProcessMySQLAccessor((\NDB_Factory::singleton())->database());

        
        return (new \Zend\Diactoros\Response())
            ->withBody(new \LORIS\Http\StringStream(json_encode(array(
                'isPhantom'    => true, 
                'pipelineRuns' => $MySQLAccessor->getSessionServerProcesses($session)
            )))
        );
    }

    public function handlePOST(ServerRequestInterface $request): ResponseInterface
    {
        $spm_module = \Module::factory('server_processes_manager');
        $server_process_id = (new ServerProcessLauncher())->legoPhantomPipeline(
            $request->getAttribute('session')
        );
        do {
            $process_state = (new ServerProcessesMonitor())
                ->getProcessesState(array($server_process_id));
        } while (trim($process_state[0]['STATE']) === 'RUNNING');

        // TODO :: an array with error and data would be better
        // TODO :: The 200 response signify that a server_rpocess was created. 
        return (new \Zend\Diactoros\Response())
            ->withBody(new \LORIS\Http\StringStream(
                json_encode($process_state[0]['STATE'])
            ))
            ->withStatus(200);
    }
}

