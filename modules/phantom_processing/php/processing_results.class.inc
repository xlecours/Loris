<?php
/**
 * Endpoint for phantom_processing results
 *
 * PHP Version 7
 *
 * @category   Endpoint
 * @package    Imaging
 * @subpackage Processing
 * @author     Xavier Lecours Boucher <xavier.lecoursboucher@mcgill.ca>
 * @license    http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link       https://www.github.com/aces/Loris-Trunk/
 */
namespace LORIS\phantom_processing;

use \Psr\Http\Message\ServerRequestInterface;
use \Psr\Http\Message\ResponseInterface;
use \Psr\Http\Server\RequestHandlerInterface;

use \Swagger\Client\Model\CbrainTask;
use \Swagger\Client\Model\FileInfo;

/**
 * Endpoint handler for phantom_processing
 *
 * PHP Version 7
 *
 * @category   Endpoint
 * @package    Imaging
 * @subpackage Processing
 * @author     Xavier Lecours Boucher <xavier.lecoursboucher@mcgill.ca>
 * @license    http://www.gnu.org/licenses/gpl-3.0.txt GPLv3
 * @link       https://www.github.com/aces/Loris-Trunk/
 */
class Processing_Results extends \NDB_Page
{
    public $skipTemplate = true;

    /**
     * @var \SplFileInfo
     */
    protected $resultdirectory;

    /**
     * Returns false if user does not have access to page.
     *
     * @return bool
     */
    function _hasAccess()
    {
        return \NDB_Factory::singleton()
            ->user()
            ->hasPermission('phantom_processing');
    }

    /**
     * An NDB_Page can act as both a middleware, or a handler, depending on the
     * context. When treated as a middleware, the page is responsible for setting
     * up any middleware required to access the page. By default, this will
     * implement the page decoration middlewares which is responsible for adding
     * the LORIS menu's/headers/footers/etc.
     * This can be overridden by modules who don't want this behaviour (such
     * as API endpoints).
     *
     * @param ServerRequestInterface  $request The PSR7 request being processed.
     * @param RequestHandlerInterface $handler The handler to handle the request
     *                                         after processing the middleware.
     *
     * @return ResponseInterface the PSR15 response that was generated by the
     * middleware
     */
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ) : ResponseInterface {

        $cbraintaskid = $request->getQueryParams()['cbraintaskid'] ?? null;

        try {
            $hook = \LORIS\CbrainHook::getInstance();

            $cbraintask = $hook->updateTask(
                new CbrainTask(array('id' => $cbraintaskid))
            );

            if ($cbraintask->getStatus() !== 'Completed') {
                return (new \Zend\Diactoros\Response())
                    ->withBody(
                        new \LORIS\Http\StringStream('')
                    )
                    ->withStatus(204);
            }

            $outputuserfileid = $cbraintask
                ->getParams()['_cbrain_output_OUTPUT_dir'][0] ?? null;

            $outputuserfile   = $hook->getUserFileByFileinfo(
                new Fileinfo(array('userfile_id' => $outputuserfileid))
            );
            $resultsdirectory = $outputuserfile->getName();

            $datadir = \NDB_Factory::singleton()
                ->config()
                ->getSetting("data");

            // TODO :: Make this a config
            $fullpath = '/data/loris-cbrain/data/processed/' . $resultsdirectory;

            $this->resultdirectory = new \SplFileinfo($fullpath);

        } catch (\Exception $e) {
            error_log(get_class($e) . '::' . $e->getMessage());
            return (new \Zend\Diactoros\Response())
            ->withBody(new \LORIS\Http\StringStream(
                json_encode(array('error' => 'No data'))
            ))
            ->withStatus(400);
        }

        return $this->handle($request);
    }

    /**
     * Handles a request and produces a response.
     *
     * @param ServerRequestInterface $request The PSR7 request being processed.
     *
     * @return ResponseInterface the PSR15 response
     */
    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        if (!empty($request->getQueryParams()['filename'])) {
            return $this->handleGETFile($request);
        } else {
            return $this->handleGET($request);
        }
    }

    protected function handleGETFile(ServerRequestInterface $request): ResponseInterface
    {
        $resultdirfullpath = $this->resultdirectory->getRealPath(); 
        $filename          = $request->getQueryParams()['filename'] ?? null;
        $outputfileinfo    = new \SplFileinfo(
            $resultdirfullpath . '/' .basename($filename)
        );

        $isFile     = $outputfileinfo->isFile();
        $isReadable = $outputfileinfo->isReadable();
        if (!$isFile || !$isReadable) {
            return (new \Zend\Diactoros\Response())
                ->withBody(
                    new \LORIS\Http\StringStream(
                        json_encode(array('error' => 'filename can`t be read'))
                    )
                )
                ->withStatus(400);
        }

        $file     = $outputfileinfo->openFile();
        $mimetype = mime_content_type($outputfileinfo->getRealPath());
        $filename = $outputfileinfo->getFilename();
    
        return (new \Zend\Diactoros\Response())
            ->withBody(new \LORIS\Http\StringStream($file->fread($file->getSize())))
            ->withHeader('Content-Type', $mimetype)
            ->withHeader('Content-Transfer-Encoding', '')
            ->withHeader('Content-disposition', "attachment; filename=\"$filename\"");
    }

    /**
     * Specialized handler for GET requests
     *
     * @param ServerRequestInterface $request The PSR7 request being processed.
     *
     * @return ResponseInterface the PSR15 response
     */
    public function handleGET(ServerRequestInterface $request): ResponseInterface
    {
        $accept = $request->getHeaderLine('Accept');
        if (preg_match('/application\/x-gtar/', $accept) === 1) {
            $filename = $this->resultdirectory->getFilename() . '.tar.gz';
            return (new \Zend\Diactoros\Response())
                    ->withBody(
                        new \LORIS\Http\StringStream($this->getTarZip())
                    )->withHeader('Content-Type', 'application/x-gtar')
                     ->withHeader('Content-Transfer-Encoding', 'Binary')
                     ->withHeader('Content-disposition', "attachment; filename=\"$filename\"");
        }

        return (new \Zend\Diactoros\Response())
            ->withBody(
                new \LORIS\Http\StringStream($this->toJSON())
            )->withHeader('Content-Type', 'application/json');
    }

    /**
     * Returns a json string representation of this page's data
     *
     * @return string
     */
    protected function toJSON(): string
    {
        return json_encode($this->toArray());
    }

    /**
     * Returns an array representation of this page's data
     *
     * @return array
     */
    protected function toArray(): array
    {
        $isDirectory = $this->resultdirectory->isDir();
        $isReadable  = $this->resultdirectory->isReadable();
        if (!$isDirectory || !$isReadable) {
            return array('error' => 'Result directory can`t be read');
        }

        $rIterator = new \RecursiveDirectoryIterator(
            $this->resultdirectory->getRealPath()
        );

        $fileinfos = array_values(iterator_to_array($rIterator));

        $files = array_map(
            function ($path) {
                $fileinfo = new \SplFileInfo($path);
                return array(
                        'filename'   => $fileinfo->getFilename(),
                        'size'       => $fileinfo->getSize(),
                        'isReadable' => $fileinfo->isReadable(),
                       );
            },
            array_filter(
                array_keys(iterator_to_array($rIterator)),
                function ($path) {
                    return (new \SplFileInfo($path))->isFile();
                }
            )
        );

        return array(
                'directory' => $this->resultdirectory->getFilename(),
                'files'     => array_values($files),
               );
    }

    protected function getTarZip(): \LORIS\Http\StringStream
    {
        $isDirectory = $this->resultdirectory->isDir();
        $isReadable  = $this->resultdirectory->isReadable();
        if (!$isDirectory || !$isReadable) {
            return json_encode(
                array('error' => 'Result directory can`t be read')
            );
        }

        $tmpdir   = sys_get_temp_dir();
        $basename = $this->resultdirectory->getFilename();

        $tarrealpath =  tempnam($tmpdir, 'processing_results_') . '.tar';
        $phar        = new \PharData($tarrealpath);

        try {
            $phar->buildFromDirectory($this->resultdirectory->getRealPath());
            $phar->compress(\Phar::GZ);
        } catch (\PharException $e) {
            error_log($e->getMessage());
            return json_encode(
                array('error' => 'tar.gz file can`t be created')
            );
        }

        $targz = new \SPLFileInfo($tarrealpath . '.gz');
        if (!$targz->isReadable()) {
            return json_encode(
                array('error' => 'tar.gz file can`t be read')
            );
        }
        unlink($tarrealpath);
        return new \LORIS\Http\StringStream(
            $targz->openFile()->fread($targz->getSize())
        );
    }

}

